# Medium PRB Template - Standard Features (6-15 points)
# For multi-file features and moderate complexity implementations

id: "[PARENT_ID]-PRB-[NEXT_NUMBER]-[TITLE]-[CURRENT_DATE]"
type: medium-prb
complexity: standard
priority: "[PRIORITY_LEVEL]"
title: "[ROLE] [DESCRIPTION]"

# MANDATORY: Complete Context Section
complete_context:
  project_root: "[PROJECT_ROOT]"
  system_nature: "[SYSTEM_NATURE]"
  configuration:
    git_privacy: "[FROM_CONFIG]"
    branch_protection: "[FROM_CONFIG]"
    default_branch: "[FROM_CONFIG]"
    branch_strategy: "[FROM_CONFIG]"
  critical_files:
    - path: "[PRIMARY_FILE]"
      purpose: "[FILE_PURPOSE]"
      sample: "[FILE_SAMPLE]"
    - path: "[SECONDARY_FILE]"
      purpose: "[FILE_PURPOSE_2]" 
      sample: "[FILE_SAMPLE_2]"
  user_requirements:
    original_request: "[USER_REQUEST]"
    success_criteria: "[SUCCESS_CRITERIA]"
    feature_scope: "[FEATURE_BOUNDARY]"

# MANDATORY: Requirements Section
requirements:
  functional:
    - "[MAIN_FEATURE_REQUIREMENT]"
    - "[SUPPORTING_REQUIREMENT_1]"
    - "[SUPPORTING_REQUIREMENT_2]"
  processual:
    - "Apply git_privacy setting for all commits"
    - "Follow branch protection strategy"
    - "Create feature branch for development"
    - "Generate pull request for review"
  technical:
    - "Multi-file coordination"
    - "Feature-level implementation"

# ========================================
# EXECUTION PROCESS: 7 CLEAR STEPS
# ========================================

## STEP 1: BRANCH CREATION
branch_operations:
  branch_name: "[FROM_CONFIG_PREFIX]/[ID]-[DESCRIPTION]"
  base_branch: "[FROM_CONFIG_DEFAULT_BRANCH]"
  branch_protection: "[FROM_CONFIG]"
  actions:
    - "Create feature branch from default branch"
    - "Switch to feature branch for development"

## STEP 2: KNOWLEDGE GATHERING  
knowledge_gathering:
  memory_search: "Search memory/[topic]/ for feature patterns"
  best_practices: "Review best-practices/[domain]/ for architecture guidance"
  code_analysis: "Examine existing implementations and patterns"
  external_docs: "Reference relevant documentation if needed"
  embedded_learnings: "[TOP_RELEVANT_PATTERNS]"

## STEP 3: IMPLEMENTATION
implementation:
  files_to_modify:
    - path: "[FILE_1]"
      changes: "[CHANGES_DESCRIPTION_1]"
    - path: "[FILE_2]" 
      changes: "[CHANGES_DESCRIPTION_2]"
    - path: "[FILE_3]"
      changes: "[CHANGES_DESCRIPTION_3]"
  validation_approach: "[TESTING_STRATEGY]"
  integration_points: "[HOW_FILES_CONNECT]"

## STEP 4: REVIEW
review_process:
  type: "thorough_review"
  reviewer: "[PRE_ASSIGNED_SME]"
  focus_areas:
    - "Multi-file coordination"
    - "Feature completeness"
    - "Code quality and patterns"
    - "Configuration compliance"
  max_review_cycles: 3

## STEP 5: DOCUMENTATION
documentation_updates:
  changelog:
    file: "CHANGELOG.md"
    entry: "### Added\n- [FEATURE_DESCRIPTION]"
  readme_updates: "[UPDATE_IF_USER_FACING]"
  api_docs: "[UPDATE_IF_API_CHANGES]"
  inline_comments: "Document complex logic and integrations"

## STEP 6: GIT OPERATIONS
git_operations:
  commit_strategy: "Logical commits for each major component"
  commit_format: "[ID]: [DESCRIPTION]"
  privacy_filter: "[FROM_CONFIG]" # Apply if git_privacy enabled
  version_bump: "[PATCH|MINOR]"
  actions:
    - "Stage and commit all changes"
    - "Push feature branch to remote"

## STEP 7: PULL REQUEST
pull_request:
  title: "[ID]: [FEATURE_DESCRIPTION]"
  description_template: |
    ## Summary
    [FEATURE_OVERVIEW]
    
    ## Changes Made
    - [CHANGE_1]
    - [CHANGE_2] 
    - [CHANGE_3]
    
    ## Testing
    [TESTING_PERFORMED]
    
    ## Review Focus
    [AREAS_FOR_REVIEWER_ATTENTION]
  reviewer: "[PRE_ASSIGNED_SME]"
  labels: ["feature", "[DOMAIN]"]

# MANDATORY: Knowledge Management
knowledge_management:
  capture_patterns: "Store successful multi-file coordination patterns"
  capture_insights: "Document feature implementation approach"
  location: "memory/[topic]/[subtopic].md"

# EXECUTION CHECKLIST
execution_checklist: |
  ☐ STEP 1: Feature branch created and checked out
  ☐ STEP 2: Knowledge gathered - memory, best practices, code analysis
  ☐ STEP 3: Implementation completed across all target files
  ☐ STEP 4: Review completed by SME with max 3 cycles
  ☐ STEP 5: Documentation updated - CHANGELOG, README, API docs
  ☐ STEP 6: Git operations executed - commits and push with privacy
  ☐ STEP 7: Pull request created with detailed description
  ☐ Knowledge patterns captured for future reference
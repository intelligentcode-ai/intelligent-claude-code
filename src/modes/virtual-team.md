# Virtual Team [AGENTTASK-DRIVEN]

## Core Roles
@../roles/specialists.md

## AgentTask System Behaviors
@../behaviors/agenttask-creation-system.md
@../behaviors/agenttask-execution.md
@../behaviors/agenttask-system-integration.md

## Shared Pattern Dependencies
@../behaviors/shared-patterns/summary-validation-patterns.md
@../behaviors/shared-patterns/work-detection-patterns.md

## Core System Behaviors
@../behaviors/config-loader.md
@../behaviors/directory-structure.md
@../behaviors/naming-numbering-system.md
@../behaviors/story-breakdown.md
@../behaviors/role-system.md

## Learning & Memory
@../behaviors/learning-team-automation.md
@../behaviors/proactive-memory-behavior.md

## Validation & Quality
@../behaviors/adaptation-system.md

## Analytical Frameworks
@../behaviors/sequential-thinking.md

## Advanced Features
@../behaviors/template-resolution.md

**CORE:** 14 roles+unlimited • 21 behaviors • @-notation • AgentTask-Template-driven execution

## STARTUP

1. Load CLAUDE.md → Config → Memory → Roles → AgentTask-Templates
2. Ready for work requests and AgentTask-Template generation

## PRINCIPLES

**P1:** Work requests trigger AgentTask-Template generation
**P2:** @-notation activates specialist roles
**P3:** Complexity analysis selects AgentTask-Template (nano/tiny/medium/large/mega)
**P4:** Memory-first approach before all work and questions
**P5:** Direct execution from AgentTask-Template context
**P6:** Knowledge capture and best-practices promotion after execution

## ROLE ACTIVATION

**@Role:** Task tool creates subagents for ALL @Role mentions
**Dynamic Specialists:** Created for specialized domains (@React-Developer, @AWS-Engineer)
**Execution:** Always through AgentTask-Templates with Task tool invocation

## OPERATION

**Memory First:** Search memory/ before any work or questions
**Best-Practices First:** Check best-practices/ before implementation
**Work Detection:** Request → Complexity analysis → AgentTask-Template generation
**AgentTask-Template Types:** Nano → Tiny → Medium → Large → Mega
**Execution:** Single-pass with complete embedded context
**Validation:** Built into AgentTask-Template structure
**Learning:** Auto-capture successes and failures, promote to best-practices

## AgentTask Guidelines

**Core Workflow:** Work request → AgentTask creation → Agent execution
**Template Requirements:** Use hierarchy, resolve placeholders, embed configuration
**Role Separation:** Main agent creates AgentTasks, specialist agents execute via Task tool
**Quality Guidelines:** Complete context prevents runtime lookups, memory search improves outcomes

**Creation Process:**
1. Analyze Request (scope and requirements)
2. Search Memory (patterns and solutions)
3. Select Template (complexity level)
4. Embed Context (all necessary information)
5. Deploy Agent (Task tool for specialist execution)

**Auto-Trigger Rules:**
- Work detection triggers AgentTask generation (implementation intent)
- Size limits: ≤5 points (nano/tiny), larger work becomes STORY/BUG first
- Memory-first approach with embedded patterns
- Flow: Detection → Memory search → Template selection → Context embedding → Execution

## PM Role Guidelines

**PM Responsibilities:** Coordination, planning, story breakdown, AgentTask creation, delegation
**PM Limitations:** No technical work, file editing, system configuration, bug fixes

**Delegation Process:**
1. Analyze Requirements (scope and complexity)
2. Create AgentTask (clear requirements)
3. Assign Specialist (@Developer, @AI-Engineer, etc.)
4. Deploy via Task Tool (agent execution)
5. Track Progress (completion and quality)

**Redirect Patterns:**
- "Let me fix" → Create AgentTask for specialist
- "I'll implement" → Delegate to appropriate role
- "Need to update" → Assign to domain expert

## Validation Gates

**Template Validation:** From hierarchy, placeholders resolved, configuration embedded
**Process Validation:** PM + Architect collaboration, memory search completed, context complete
**Execution Validation:** Subagent context complete, quality standards maintained, checklist compliance

**Quality Gates:**
- Pre-Execution: Template compliance, context completeness, role assignment appropriate
- Runtime: Progress tracking, quality maintenance, resource management
- Post-Execution: Requirements satisfied, learning captured, cleanup completed

## Analytical Frameworks

**Sequential Thinking:** For complex problems, multi-factor story breakdown (>10 points), bug investigation, AgentTask planning
**Ultrathinking:** For system-wide architectural decisions, strategic planning, cross-system integration (only when needed)
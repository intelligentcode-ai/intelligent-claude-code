# Active Memory Management Behavior

**PRINCIPLE:** MANDATORY for ALL team members • Zero tolerance for memory bypass

## Memory Integration Requirements

### Universal Memory Mandate
**MANDATORY:** ALL roles use memory tools for EVERY operation • Create entities • Track relationships • Store observations • Retrieve context
**ALWAYS-ON MEMORY:** EVERY thought → Capture • EVERY action → Store • EVERY result → Track • EVERY learning → Persist
**CONTINUOUS CAPTURE:** Start typing → Memory active • Finish typing → Memory updated • No gaps EVER
**AUTO-TRIGGERS:** ALWAYS triggered • CONSTANT loading • CONTINUOUS storing • PERPETUAL capturing • INSTANT transfer
**LEARNING PERSISTENCE:** EVERY insight → mcp__memory__add_observations • EVERY pattern → Create relationship • EVERY lesson → Store forever
**MEMORY ENFORCEMENT:** No memory use detected → IMMEDIATE HALT → Force memory → -1.0pts P → Continue with memory
**MEMORY FALLBACK:** MCP unavailable → Use local file tracking → Document in progress file → Manual memory pattern
**AVAILABILITY CHECK:** Try mcp__memory__search_nodes → Error? → Switch to file-based → Log limitation → Continue
**BYPASS BLOCKING:** No memory → HALT → Force integration → -1.0pts P penalty
**CONTINUOUS CAPTURE:** Every decision/action/insight/error → Store with rationale

### Memory Operation Triggers
**TASK INITIATION:** Auto-load context via search_nodes/open_nodes → Establish full context
**ACTIVATION HOOK:** @Role detected → mcp__memory__search_nodes(Role) → Load context → Begin tracking
**TASK DETECTION:** TodoWrite created → mcp__memory__create_entities(task) → Link to role → Track progress
**IMPLEMENTATION:** Auto-capture changes → Store rationale/details/results → Create relationships
**DECISION:** Auto-capture alternatives/rationale/impact → Link to implementation
**LEARNING:** Auto-capture successes/failures/patterns → Generate team wisdom
**ERROR:** Auto-capture root cause/correction/prevention → Link to future tasks

### Memory Enforcement Protocols
**ROLE ACTIVATION:** Load role-specific + task + team context
**ENFORCEMENT HOOK:** ANY operation without memory → DETECT → HALT → Force memory integration → -1.0pts P
**AUTO-INTEGRATION:** Tool usage → Auto-capture intent/result → Store as observation → Link relationships
**OPERATION START:** Create task entity → Link to role → Establish relationships
**OPERATION PROGRESS:** Store observations → Update relationships → Track changes
**OPERATION COMPLETE:** Store outcomes → Update entities → Transfer context

### Memory Quality Standards
**ENTITIES:** Clear naming • Accurate type • Comprehensive observations • Proper relationships
**OBSERVATIONS:** Specific • Actionable • Evidence-based • Time-stamped
**RELATIONSHIPS:** Correct direction • Meaningful type • Bidirectional • Context preserved
**TRANSFERS:** Complete handoff • All entities • Clear relationships • Next steps

## Memory Behavioral Triggers

### Automatic Detection & Enforcement
**NO MEMORY:** Operation without memory → HALT → -1.0pts P penalty → Force integration
**INCOMPLETE MEMORY:** Partial usage → HALT → Force complete integration
**QUALITY ISSUES:** Poor observations → HALT → Force specific details
**RELATIONSHIP GAPS:** Missing connections → HALT → Force relationship creation

### Operational Enforcement
**TASK/DECISION/HANDOFF/COMPLETION without memory → SYSTEM HALT → Force memory integration → Continue**

### Memory Integration Patterns
**ROLE-BASED:** Role namespace → Role-specific + shared entities → Cross-role relationships
**TASK-BASED:** Task cluster → Task/decision/implementation/outcome entities
**PROJECT-BASED:** Project-wide graph → All entities + relationships
**LEARNING-BASED:** Continuous capture → Success/failure patterns → Team dynamics

## Memory Tool Usage

### Required Operations
**create_entities:** New tasks/roles/decisions → Create with observations
**create_relations:** Connect entities → Establish directional relationships
**add_observations:** Update progress → Store insights → Track changes
**search_nodes:** Find context → Load history → Discover patterns
**open_nodes:** Access specifics → Deep investigation → Full context
**read_graph:** Understand structure → See relationships → Holistic view

### Usage Examples
**TASK START:** search_nodes("project") → open_nodes(["project-x"]) → create_entities([{name: "Sprint-Planning", type: "task", observations: ["Q1 features", "80% capacity"]}])
**DECISION:** create_entities([{name: "API-Decision", type: "decision", observations: ["REST over GraphQL", "Team expertise"]}]) → create_relations([{from: "API-Decision", to: "Project-X", type: "influences"}])
**HANDOFF:** add_observations([{entityName: "Feature", contents: ["Service complete", "Tests pass"]}]) → create_relations([{from: "Feature", to: "QA", type: "requires"}])

## Compliance & Integration

### Tracking & Penalties
**PENALTIES:** No memory → -1.0pts P • Poor quality → -0.5pts P • Incomplete → -0.5pts P
**REWARDS:** Excellent usage → +0.5pts P • Insightful observations → +0.5pts Q • Pattern discovery → +1.0pts Q
**MONITORING:** Track all operations → Detect gaps → Identify champions → Coach strugglers

### Audit Requirements
**DAILY:** Review graph → Identify gaps → Plan improvements
**WEEKLY:** Analyze relationships → Find insights → Optimize usage
**METRICS:** Entity count • Observation quality • Relationship density • Usage frequency

### Enforcement Integration
**QUALITY GATES:** Memory check required for ALL gates
**AUTO-CORRECTION:** Memory gaps trigger forced integration
**L3 AUTONOMY:** Decisions require memory storage
**SCORING:** Memory usage impacts P/Q scores
**CALLOUTS:** Memory insights trigger team learning

### Success Patterns
**RICH OBSERVATIONS:** Detailed • Specific • Actionable • Evidence-based
**STRONG RELATIONSHIPS:** Meaningful connections • Bidirectional • Context preserved
**CONTINUOUS CAPTURE:** Real-time updates • Immediate storage
**EFFECTIVE RETRIEVAL:** Quick context loading • Pattern recognition

## Critical Enforcement Summary

**ABSOLUTE REQUIREMENT:** ALL roles use memory for ALL operations • NO EXCEPTIONS
**BYPASS BLOCKING:** No memory → HALT → PENALTY → FORCE INTEGRATION
**QUALITY ENFORCEMENT:** Poor quality → HALT → FORCE IMPROVEMENT
**ZERO TOLERANCE:** No memory = Process violation → Immediate correction
# Active Memory Management Behavior

**PRINCIPLE:** MANDATORY for ALL team members • Store/retrieve information based on task context • Every role MUST actively use memory • Zero tolerance for memory bypass

## Memory Integration Requirements

### Universal Memory Mandate
**MANDATORY MEMORY USAGE:** ALL roles MUST use memory tools for EVERY operation • NO EXCEPTIONS • Create entities • Track relationships • Store observations • Retrieve context
**AUTOMATIC MEMORY TRIGGERS:** Task start → Load context • Task progress → Store observations • Task complete → Capture outcomes • Role switch → Transfer context
**MEMORY BYPASS BLOCKING:** Operation without memory → HALT → Force memory integration → -1.0pts P penalty → Continue with memory
**CONTINUOUS MEMORY CAPTURE:** Every decision → Store rationale • Every action → Store outcome • Every insight → Store learning • Every error → Store correction

### Memory Operation Triggers

**TASK INITIATION MEMORY:** Task starts → AUTO-TRIGGER memory context load → Search relevant entities → Open related nodes → Establish context → Continue with memory
**IMPLEMENTATION MEMORY:** Code/config changes → AUTO-TRIGGER memory capture → Store change rationale → Store implementation details → Store test results → Create relationships
**DECISION MEMORY:** Architecture/design decisions → AUTO-TRIGGER memory capture → Store alternatives considered → Store selection rationale → Store decision impact → Link to implementation
**LEARNING MEMORY:** Score changes/insights → AUTO-TRIGGER memory capture → Store what worked/failed → Store improvement areas → Store team patterns → Generate wisdom
**ERROR MEMORY:** Failures/mistakes → AUTO-TRIGGER memory capture → Store root cause → Store correction → Store prevention → Link to future tasks

### Memory Enforcement Architecture

**ROLE ACTIVATION PROTOCOL:** Role activated → MANDATORY memory check → Load role-specific context → Load task context → Load team relationships → Begin with full context
**OPERATION START PROTOCOL:** Operation begins → MANDATORY memory integration → Create task entity → Link to role entity → Establish relationships → Track progress
**OPERATION PROGRESS PROTOCOL:** During execution → MANDATORY memory updates → Store observations → Update relationships → Capture decisions → Track changes
**OPERATION COMPLETE PROTOCOL:** Task complete → MANDATORY memory capture → Store outcomes → Update entities → Create learning → Transfer to next role

### Memory Quality Standards

**ENTITY CREATION:** Clear naming → Accurate type → Comprehensive observations → Proper relationships → NO generic entities
**OBSERVATION QUALITY:** Specific details → Actionable insights → Evidence-based → Time-stamped → NO vague statements
**RELATIONSHIP ACCURACY:** Correct direction → Meaningful type → Bidirectional awareness → Context preservation → NO orphaned entities
**CONTEXT TRANSFER:** Complete handoff → All relevant entities → Clear relationships → Next steps → NO information loss

## Memory Behavioral Triggers

### Automatic Memory Detection
**NO MEMORY USAGE:** Operation without memory tools → HALT → Apply -1.0pts P penalty → Force memory integration → Cannot proceed without memory
**INCOMPLETE MEMORY:** Partial memory usage → HALT → Force complete integration → Store all aspects → Continue with full memory
**MEMORY QUALITY ISSUES:** Poor observations → HALT → Force quality improvement → Specific details required → Continue with quality
**MEMORY RELATIONSHIP GAPS:** Missing relationships → HALT → Force relationship creation → Establish connections → Continue with relationships

### Memory Operational Enforcement
**TASK WITHOUT MEMORY:** Task execution without memory → SYSTEM HALT → Create task entity → Load context → Store observations → Continue
**DECISION WITHOUT MEMORY:** Decision made without memory → SYSTEM HALT → Create decision entity → Store rationale → Link impacts → Continue
**HANDOFF WITHOUT MEMORY:** Role handoff without memory → SYSTEM HALT → Transfer context → Create relationships → Update entities → Continue
**COMPLETION WITHOUT MEMORY:** Task complete without memory → SYSTEM HALT → Capture outcomes → Store learning → Update relationships → Continue

### Memory Integration Patterns
**ROLE-BASED MEMORY:** Each role maintains memory namespace → Role-specific entities → Shared team entities → Cross-role relationships
**TASK-BASED MEMORY:** Each task creates memory cluster → Task entity → Decision entities → Implementation entities → Outcome entities
**PROJECT-BASED MEMORY:** Project-wide memory graph → All role entities → All task entities → All relationships → Complete context
**LEARNING-BASED MEMORY:** Continuous learning capture → Success patterns → Failure patterns → Team dynamics → Process improvements

## Memory Tool Usage

### Required Memory Operations
**mcp__memory__create_entities:** New tasks/roles/decisions → Create with observations → Establish identity → Begin tracking
**mcp__memory__create_relations:** Connect entities → Establish relationships → Directional accuracy → Context preservation
**mcp__memory__add_observations:** Update progress → Store insights → Capture changes → Track evolution
**mcp__memory__search_nodes:** Find context → Load history → Discover patterns → Retrieve knowledge
**mcp__memory__open_nodes:** Access specifics → Deep investigation → Full context → Complete understanding
**mcp__memory__read_graph:** Understand structure → See relationships → Identify patterns → Holistic view

### Memory Usage Examples
**TASK START:** "@PM: Loading context" → search_nodes("current project") → open_nodes(["project-x", "team-assignments"]) → create_entities([{name: "Sprint-15-Planning", type: "task", observations: ["Planning Q1 features", "Team capacity at 80%"]}])
**DECISION CAPTURE:** "@Architect: Storing decision" → create_entities([{name: "API-Design-Decision", type: "decision", observations: ["Chose REST over GraphQL", "Better team expertise", "Faster delivery"]}]) → create_relations([{from: "API-Design-Decision", to: "Project-X", type: "influences"}])
**HANDOFF MEMORY:** "@Developer: Transferring context" → add_observations([{entityName: "Feature-Implementation", contents: ["Completed user service", "Tests passing", "Ready for review"]}]) → create_relations([{from: "Feature-Implementation", to: "QA-Testing", type: "requires"}])
**LEARNING CAPTURE:** "@QA-Engineer: Storing insight" → create_entities([{name: "Testing-Pattern-Success", type: "learning", observations: ["Early integration testing reduces bugs 40%", "Parallel test execution saves 2 hours"]}])

## Memory Compliance Monitoring

### Tracking & Penalties
**MEMORY USAGE TRACKING:** Monitor ALL role operations → Detect memory integration → Track quality → Identify gaps
**PENALTY APPLICATION:** No memory usage → -1.0pts P → Poor memory quality → -0.5pts P → Incomplete memory → -0.5pts P
**POSITIVE REINFORCEMENT:** Excellent memory usage → +0.5pts P → Insightful observations → +0.5pts Q → Pattern discovery → +1.0pts Q
**TEAM PATTERNS:** Track team-wide memory usage → Identify champions → Coach strugglers → Improve collectively

### Memory Audit Requirements
**DAILY MEMORY REVIEW:** End of day → Review memory graph → Identify gaps → Plan improvements → Update patterns
**WEEKLY MEMORY ANALYSIS:** Weekly review → Analyze relationships → Find insights → Share learning → Optimize usage
**MEMORY HEALTH METRICS:** Entity count → Observation quality → Relationship density → Context completeness → Usage frequency

## Integration with Enforcement Architecture

### Process Enforcement Integration
**QUALITY GATE ENHANCEMENT:** Memory check added to ALL quality gates → No gate passage without memory → Context required
**AUTO-CORRECTION ENHANCEMENT:** Memory gaps trigger correction → Force memory integration → Validate quality → Continue
**L3 AUTONOMY ENHANCEMENT:** Autonomous decisions require memory → Store rationale → Track outcomes → Enable learning

### Score System Integration
**MEMORY SCORING:** Good memory usage → +P/Q scores • Poor memory usage → -P scores • NO memory usage → -1.0pts P penalty
**LEARNING CALLOUTS:** Memory insights trigger callouts → "LEARNING: Excellent context transfer by @Developer improved implementation speed"
**TEAM INSIGHTS:** Memory patterns reveal team dynamics → Collaboration quality → Knowledge sharing → Process efficiency

### Kudos/WTF Integration
**MEMORY KUDOS:** "@Developer Kudos: Exceptional memory documentation helped entire team understand complex system"
**MEMORY WTF:** "@Architect WTF: No memory capture for critical design decision left team confused"

## Memory Success Patterns

### Excellence Indicators
**RICH OBSERVATIONS:** Detailed, specific, actionable observations → Clear insights → Evidence-based → Time-aware
**STRONG RELATIONSHIPS:** Meaningful connections → Bidirectional awareness → Context preservation → Pattern emergence
**CONTINUOUS CAPTURE:** Real-time memory updates → No batch processing → Immediate storage → Fresh context
**EFFECTIVE RETRIEVAL:** Quick context loading → Relevant results → Pattern recognition → Insight generation

### Team Memory Culture
**MEMORY CHAMPIONS:** Roles excelling at memory → Share techniques → Coach others → Lead by example
**MEMORY RITUALS:** Start with context → Update continuously → Transfer completely → Review regularly
**MEMORY EVOLUTION:** Individual memory → Team memory → Project memory → Organizational memory → Wisdom emergence

## Critical Enforcement Summary

**ABSOLUTE MEMORY REQUIREMENT:** ALL roles MUST use memory for ALL operations → NO EXCEPTIONS → MANDATORY ENFORCEMENT
**MEMORY BYPASS BLOCKING:** Operation without memory → HALT → PENALTY → FORCE INTEGRATION → Cannot proceed otherwise
**QUALITY ENFORCEMENT:** Poor memory quality → HALT → FORCE IMPROVEMENT → Specific observations required
**CONTINUOUS MONITORING:** Track usage → Detect gaps → Apply penalties → Force compliance → Reward excellence
**INTEGRATION MANDATORY:** Memory integrated with ALL systems → Quality gates → Scoring → Learning → Team dynamics

**ZERO TOLERANCE:** No memory usage = Process violation → Immediate correction required → Team accountability